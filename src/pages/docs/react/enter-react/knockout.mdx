

## KnockoutJS’ning rivojlanishi
Keling, ushbu yondashuvni o‘sha paytda keng tarqalgan boshqa bir mashhur yechim — KnockoutJS bilan solishtiramiz. KnockoutJS 2010-yillar boshlarida yaratilgan va u "observables"(kuzatiladigan narsalar) va "bindings"(bog'lashlar) yaratish uchun imkoniyat bergan kutubxona edi. Bu usul har safar holat o‘zgarganda bog‘liqlikni kuzatib borishni ta'minlardi.

KnockoutJS eng dastlabkilardan yoki birinchi bo‘lgan reaktiv JavaScript kutubxonalaridan biri edi. Bu yerda reaktivlik deganda, qiymatlar observables usulida holat o‘zgarishlariga javob berib yangilanishi tushuniladi. Zamonaviy reaktivlik usullari ba'zan "signallar" deb ataladi va ular Vue.js, SolidJS, Svelte, Qwik, hamda zamonaviy Angular kabi kutubxonalarda keng qo‘llaniladi.

Observables tushunchasi bu — kuzatilishi mumkin bo'lgan ma'lumot manbai, bindings esa — ushbu ma'lumotni iste'mol qiladigan va uni foydalanuvchi interfeysida ko‘rsatadigan elementlar edi: observables modelga o‘xshar edi, bindings esa view vazifasini bajarardi.

Ammo, biz oldinroq muhokama qilgan MVC (Model-View-Controller) patternining bir oz rivojlangan shakli sifatida, KnockoutJS Model-View-ViewModel yoki MVVM patternga yaqinroq ishlardi (rasmga qarang). Keling, bu patternni batafsilroq tushunishga harakat qilamiz.

![Hello](/mvvm-pattern.png)


### MVVM pattern
MVVM (Model-View-ViewModel) patterni — bu o‘ziga xos arxitektura dizaynidir va ayniqsa WPF va Xamarin platformalarida yaratilgan murakkab foydalanuvchi interfeyslari uchun mashhurdir. Bu, an'anaviy MVC patternining rivojlangan shakli bo‘lib, zamonaviy UI dasturlash platformalariga moslashtirilgan. Quyida MVVM tarkibiy qismlarini qisqacha ko‘rib chiqamiz:

##### Model
- Dasturning ma'lumotlari va biznes logikalarini ifodalaydi.
- Ma'lumotlarni olish, saqlash va qayta ishlash uchun javobgardir.
- Odatda, u ma'lumotlar bazasi, servislar yoki boshqa ma'lumot manbalari bilan ishlaydi.
- View va ViewModel bilan bog‘liq emas, ulardan bexabar.

##### View
- Dasturning foydalanuvchi interfeysini ifodalaydi.
- Foydalanuvchiga ma'lumotni ko‘rsatadi va foydalanuvchi kiritgan ma'lumotlarni qabul qiladi.
- MVVMda View passiv hisoblanadi va hech qanday dastur logikasiga ega emas. Buning o‘rniga, u ViewModel bilan deklarativ tarzda bog‘lanadi va ma'lumotlarni avtomatik tarzda yangilab turadi.

##### ViewModel
- Model va View o‘rtasidagi ko‘prik vazifasini bajaradi.
- View uchun ma'lumotlar va buyruqlarni ko‘rsatadi. Bu ma'lumotlar ko‘pincha tayyor ko‘rinishga ega formatda bo‘ladi.
- Foydalanuvchi kiritgan ma'lumotlarni boshqaradi, ko‘pincha buyruq patterni orqali.
- Ma'lumotlarni Modeldan olib, Viewda osongina ko‘rinadigan formatga aylantiradi.
- Muhimi, ViewModel ishlatilayotgan maxsus Viewdan bexabar, bu esa mustaqil arxitekturani yaratishga imkon beradi.


### MVVM patternining afzalliklari
MVVM patternining asosiy afzalligi MVCga o‘xshash vazifalarni ajratish prinsipi hisoblanadi, bu quyidagi yutuqlarga olib keladi:

- **Testlash qulayligi**: ViewModel va View o‘rtasidagi mustaqillik UIni ishtirok ettirmasdan unit testlar yozishni osonlashtiradi.
- **Qayta foydalanish qulayligi**: ViewModel turli ko‘rinishlar yoki platformalar o‘rtasida qayta foydalanilishi mumkin.
- **Qo‘llab-quvvatlash qulayligi (Maintainability)**: MVVM patternida aniq ajratilgan vazifalar tufayli, kodni boshqarish, kengaytirish va qayta ko‘rib chiqish osonlashadi.
- **Ma’lumot bog‘lash qulayligi (Data binding)**: MVVM patterni ma’lumot bog‘lashni qo‘llab-quvvatlovchi platformalarda juda yaxshi ishlaydi. Bu interfeys yangilanishi uchun yozilishi kerak bo‘lgan ortiqcha kodni kamaytiradi.


### MVC va MVVMning asosiy farqlari
| **Kriteriya**  | **MVC** | **MVVM** |
| :----- | :----: | ----: |
| **Asosiy maqsad**  |  Veb-dasturlar uchun foydalanuvchi interfeysi va logikani ajratadi.   |   Murakkab UI ilovalari uchun mo'ljallangan, ayniqsa desktop yoki SPA kabi ikki tomonlama ma’lumot bog‘lashni ta'minlaydi. ||
| **Komponentlar**  | Model: ma'lumot va biznes logikasi. View: foydalanuvchi interfeysi. Controller: foydalanuvchi kiritgan ma'lumotlarni boshqaradi.  |  Model: ma'lumot va biznes logikasi. View: foydalanuvchi interfeysi elementlari. ViewModel: Model va View orasida ko‘prik. ||
| **Ma’lumot oqimi**  | Controller foydalanuvchi kiritgan ma'lumotlarni boshqaradi, u Model va Viewni yangilaydi.  |  View to‘g‘ridan-to‘g‘ri ViewModel bilan bog‘lanadi. Viewdagi o'zgarishlar avtomatik ravishda ViewModelda aks ettiriladi va aksincha. ||
| **Ajratish darajasi**  | View odatda Controller bilan mustahkam bog‘langan.  |  ViewModel alohida Viewdan mustaqil bo'lgani uchun, yuqori darajada ajratish imkoniyatini beradi |
| **Foydalanuvchi bilan o‘zaro ta’sir (User interaction)**  | Controller tomonidan boshqariladi  |  ViewModeldagi ma'lumot bog‘lashlar va buyruqlar orqali boshqariladi. |
| **Platformaga moslik**  | Veb platformalariga mos (Ruby on Rails, Django, ASP.NET MVC kabilar).  |  Ma'lumot bog‘lashni qo‘llab-quvvatlovchi platformalar uchun mos (WPF, Xamarin kabilar). |

Ushbu qisqa taqqoslashdan ko‘rinib turibdiki, MVC va MVVM patternlarining haqiqiy farqi bog‘lanish va ma'lumotni bog‘lash uslubida: Model va View o‘rtasida Controller mavjud emasligi sababli, ma'lumotlarga egalik qilish foydalanuvchiga aniqroq va yaqinroq bo'ladi. React bu borada MVVM patternini yanada yaxshilab, bir tomonlama ma'lumot oqimini ta'minlaydi, bu esa ma'lumotga egalik qilishni yanada aniqroq qiladi, shunday qilib, holat faqat unga ehtiyoj sezadigan komponentlarga tegishli bo‘ladi. Hozircha KnockoutJSga qaytaylik va uning React bilan qanday bog‘liqligini ko‘rib chiqaylik.

KnockoutJS observables va bindings bilan ishlash uchun API’lar eksport qilgan. Endi KnockoutJSda "Like" buttonni qanday amalga oshirganimizni ko‘rib chiqaylik. Bu bizga “Nega React kerak?” degan savolga yaxshiroq tushunishimizga yordam beradi. Bu yerda  KnockoutJSdagi button kodini ko‘rib chiqamiz:
``` js copy
function createViewModel({ liked }) {
    const isPending = ko.observable(false);
    const hasFailed = ko.observable(false);
    const onClick = () => {
        isPending(true);
        fetch("/like", {
            method: "POST",
            body: JSON.stringify({ liked: !liked() })
        })
        .then(() => {
            liked(!liked());
        })
        .catch(() => {
            hasFailed(true);
        })
        .finally(() => {
            isPending(false);
        });
    };
    return { isPending, hasFailed, onClick, liked };
}

ko.applyBindings(createViewModel({ liked: ko.observable(false) }));
```

KnockoutJSda "view model" JavaScript obyekti bo‘lib, u o‘zida bizning sahifamizdagi turli elementlarga bog‘langan kalitlar va qiymatlarni saqlaydi, bunda `data-bind` atributidan foydalaniladi. KnockoutJSda hech qanday "komponentlar" yoki "shablonlar" yo‘q, faqat view model va uni brauzerda elementlarga bog‘lash usuli mavjud.

Bizning `createViewModel` funksiyamiz KnockoutJS yordamida qanday qilib view model yaratishni ko‘rsatadi. Shundan so‘ng biz `ko.applyBindings` funksiyasidan foydalanib, view modelni host muhit(brauzer) bilan bog‘laymiz. `ko.applyBindings` funksiyasi view modelni oladi va brauzerda `data-bind` atributiga ega bo‘lgan barcha elementlarni topadi, shundan keyin Knockout ularni view model bilan bog‘laydi.

Brauzerimizdagi button quyidagi tarzda view model xususiyatlariga bog‘lanadi:
``` js copy
<button
    data-bind="click: onClick, text: liked ? 'Liked' : isPending ? 'Loading...' : 'Like'"
></button>
```

Shuni ta'kidlash kerakki, bu kod soddalashtirish maqsadida qisqartirilgan.

Biz HTML elementini `createViewModel` funksiyamiz bilan yaratgan view modelimiz bilan bog‘laymiz va sayt interaktiv holga keladi. Tasavvur qilganingizdek, kuzatilishi mumkin bo'lgan o‘zgarishlariga aniq obuna bo‘lish va keyin foydalanuvchi interfeysini bu o‘zgarishlarga javoban yangilash katta mehnat talab qiladi. KnockoutJS o‘z davrining ajoyib kutubxonasi bo‘lgan, lekin vazifani bajarish uchun ko‘p qo‘shimcha kod(boilerplate) talab qilingan.

Bundan tashqari, view modellari juda katta va murakkab bo‘lib ketar edi, bu esa kodni refaktor qilish va optimizatsiya qilishda muammolarga olib kelgan. Oxir-oqibat, bu narsa testlash va tushunish qiyin bo'lgan juda uzun va monolit view modellariga olib keldi. Shunga qaramay, KnockoutJS o‘z davrida juda ommabop va katta yutuqqa erishgan kutubxona edi. U izolyatsiya qilingan holatda testlash uchun ham nisbatan oson bo‘lgan, bu katta ustunlik hisoblanardi.

Esdalik uchun, KnockoutJSda bu buttonni qanday test qilganimizni ko‘rib chiqamiz:
``` js copy
test("LikeButton", () => {
    const viewModel = createViewModel({ liked: ko.observable(false) });
    expect(viewModel.liked()).toBe(false);
    viewModel.onClick();
    expect(viewModel.liked()).toBe(true);
});
```
